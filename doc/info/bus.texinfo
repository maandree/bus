\input texinfo   @c -*-texinfo-*-

@c %**start of header
@setfilename bus.info
@settitle bus
@afourpaper
@documentencoding UTF-8
@documentlanguage en
@finalout
@c %**end of header


@dircategory Interprorcess Communication
@direntry
* bus: (bus).                        A simple daemonless system for broadcasting messages locally
@end direntry


@copying
Copyright @copyright{} 2015 Mattias Andrée

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts. A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@ifnottex
@node Top
@top bus -- A simple daemonless system for broadcasting messages locally
@insertcopying
@end ifnottex

@titlepage
@title bus
@subtitle A simple daemonless system for broadcasting messages locally
@author by Mattias Andrée (maandree)

@page
@vskip 0pt plus 1filll
@insertcopying
@page
@end titlepage

@contents


@iftex
@macro xrm{}
@rm{}
@end macro
@macro xtt{}
@tt{}
@end macro
@end iftex

@ifnottex
@macro xrm{}
@end macro
@macro xtt{}
@end macro
@end ifnottex



@menu
* Overview::                        Brief overview of @command{bus}.
* Standard::                        How to use @command{bus} properly.
* Invoking::                        Executing @command{bus}.
* Interface::                       Using @command{libbus}.
* Protocol::                        How communication over @command{bus} works internally.
* Rationale::                       Why @command{bus}?
* Examples::                        Usecase examples and API-demonstration.
* GNU Free Documentation License::  Copying and sharing this manual.
@end menu
@c TODO @detailmenu (`C-c C-u m`)



@node Overview
@chapter Overview

@command{bus} is a stupid-simple, thrilless, daemonless interprocess
communication system for broadcasting messages. It is a lightweight
alternative to a two-phase interprocess flexible barrier.

@command{bus} uses a System V semaphore array and System V shared
memory. Buses are named; the key of the semaphore array and the
shared memory is stored in a regular file.

The shared memory used by @command{bus} is always 2048 bytes.
Additionally all messages should be encoded in UTF-8 and not contain
any NULL characters, except they @emph{must} always end with a NULL
byte. Furthermore messages should be prefixed with the process
identifer of the process whence the message originated, followed
by a space. If the process is ephemeral@footnote{The process exits
after the broadcast, or shortly thereafter.}, 0 should be used
instead of the process identifier.

Communication over @command{bus} is synchronous. The broadcast call
does not return until all listeners have received (and copied) the
message. A malfunctioning program can lock the bus.

This software package contains a C library and a command line
utility. The package python-bus provides a Python 3 module.



@node Standard
@chapter Standard

The command @command{bus create} can be used to create new buses. By
convention, buses should be stored in @file{$XDG_RUNTIME_DIR/bus},
this is what @command{bus create} does if no pathname is given. The
pathname of the bus should be tracked using @env{BUS_X}, where @env{X}
is replaced with either:

@table @env
@item GENERIC
For the bus used in generic cases. That is all but the cases
of the buses listed below.
@item AUDIO
For the bus used in with the audio subsystem is involved.
@item VIDEO
For the bus used in with the video subsystem is involved.
@item INPUT
For the bus used in with the input subsystem is involved.
@item FILES
For the bus used in with the storage subsystem is involved.
@end table

This list may be extended in the future. Therefore, and for
other conventions, project-private buses should be tracked
using @env{X_BUS}, where @env{X} is the project name.

Messages broadcasted on a bus cannot be longer than 2047 bytes,
excluding NUL termination. Message should be encoded in UTF-8,
and most not contain the NUL character.

Broadcasted message should start with the process ID whence
the message originated, followed by a single regular space.
If the process is ephemeral@footnote{The process exits after
the broadcast, or shortly thereafter.}, 0 should be used instead
of the process identifier.



@node Invoking
@chapter Invoking

@command{bus} includes the following commands:

@table @command
@item create
Create a bus.
See @ref{bus create} for more information.
@item remove
Remove a bus.
See @ref{bus remove} for more information.
@item listen
Listen for new message on a bus.
See @ref{bus listen} for more information.
@item wait
Listen for one new message only on a bus.
See @ref{bus wait} for more information.
@item broadcast
Broadcast a message on a bus.
See @ref{bus broadcast} for more information.
@item chmod
Change permissions on a bus.
See @ref{bus chmod} for more information.
@item chown
Change ownership of a bus.
See @ref{bus chown} for more information.
@item chgrp
Change group ownership of a bus.
See @ref{bus chgrp} for more information.
@end table

Upon successful completion, these commands exit with the value
0. On failure, they exit with the value 1. If the command is
not recognised the exit value is 2.

@menu
* bus create::                      Create a bus.
* bus remove::                      Remove a bus.
* bus listen::                      Listen for new message on a bus.
* bus wait::                        Listen for one new message only on a bus.
* bus broadcast::                   Broadcast a message on a bus.
* bus chmod::                       Change permissions on a bus.
* bus chown::                       Change ownership of a bus.
* bus chgrp::                       Change group ownership of a bus.
@end menu



@node bus create
@section @command{bus create}

The syntax for invocation of @command{bus create} is
@example
bus create [-x] [--] [@var{PATHNAME}]
@end example

The command creates a bus and stores the key to it in the
file @var{PATHNAME}. If @var{PATHNAME} is omitted, a
random pathname in @file{$XDG_RUNTIME_DIR/bus} will be
used and printed to stdout.

If @option{-x} is used, the command will fail if
the file @var{PATHNAME} already exists.




@node bus remove
@section @command{bus remove}

The syntax for invocation of @command{bus remove} is
@example
bus remove [--] @var{PATHNAME}
@end example

The command removes the bus whose key is stored in
the file @var{PATHNAME}.  The file holding the
key is also unlinked.



@node bus listen
@section @command{bus listen}

The syntax for invocation of @command{bus command} is
@example
bus listen [--] @var{PATHNAME} @var{COMMAND}
@end example

The command listens for new messages on the bus whose
key is stored in the file @var{PATHNAME}. Once a message
is received, @var{COMMAND} will be spawned with the
environment variable @env{msg} (lowercased) set to the
received message. @sc{POSIX} shell syntax applies to
@var{COMMAND}.


@node bus wait
@section @command{bus wait}

The syntax for invocation of @command{bus wait} is
@example
bus wait [--] @var{PATHNAME} @var{COMMAND}
@end example

The command listens for a new message on the bus whose
key is stored in the file @var{PATHNAME}. Once a message
is received, the process will stop listening for more
messages and @var{COMMAND} will be spawned with the
environment variable @env{msg} (lowercased) set to the
received message. @sc{POSIX} shell syntax applies to
@var{COMMAND}.



@node bus broadcast
@section @command{bus broadcast}

The syntax for invocation of @command{bus broadcast} is
@example
bus broadcast [-n] [--] @var{PATHNAME} @var{MESSAGE}
@end example

The command broadcasts the message @var{MESSAGE} on the
bus whose key is stored in the file @var{PATHNAME}.



@node bus chmod
@section @command{bus chmod}

The syntax for invocation of @command{bus chmod} is
@example
bus chmod [--] @var{PERMISSIONS} @var{PATHNAME}
@end example

This command changes who have access to the bus whose key
is stored in the file @var{PATHNAME}. In the permissions,
the owner, the group, and others (not in tgroup) are
represented by the symbols @code{u}@footnote{@code{u}
stands for `user'.}, @code{g}, and @code{o}, respectively.
The permissions string is imagined to have always be
prefixed with an @code{=}. This symbols means that all user
classes list after it, and only those classes, as permission
to use the bus. Similarly the symbols @code{+} and @code{-}
can be used to grant and revoke access, respectively. The
symbols @code{=}, @code{+}, and @code{-} can be mixed, and
are interpreted from left to right. Alternatively the
permissions string can be a octal number, where the  owner
is represented by any bit in 700 (100, 200, or 400, or any
combination thereof), the group is represented by any bit
in 70, and others (not in the group) is represented by any
bit in 7.

The current permission of the bus can be retrieved by
running @command{stat} over the file @var{PATHNAME}.



@node bus chown
@section @command{bus chown}

The syntax for invocation of @command{bus chown} is
@example
bus chown [--] @var{OWNER}[:@var{GROUP}] @var{PATHNAME}
@end example

This command changes the owner, that owns the bus whose
key is stored in the file @var{PATHNAME}, to the specified
owner. The owner can be specified either with a numerical
user identifier or with a user name. If a group is
specified, the bus's owner-group will be set to that group,
otherwise the group will remain unchanged (not changed
to the group of the new owner.) The group can be specified
either with a numerical group identifier or with a group
name.

The current ownership of the bus can be retrieved by
running @command{stat} over the file @var{PATHNAME}.



@node bus chgrp
@section @command{bus chgrp}

The syntax for invocation of @command{bus chgrp} is
@example
bus chgrp [--] @var{GROUP} @var{PATHNAME}
@end example

This command changes the group, that owns the bus whose
key is stored in the file @var{PATHNAME}, to the specified
group. The group can be specified either with a numerical
group identifier or with a group name.

The current ownership of the bus can be retrieved by
running @command{stat} over the file @var{PATHNAME}.



@node Interface
@chapter Interface

To use @command{libbus} in your C program, include the
header file @file{<bus.h>} and link with the flag
@option{-lbus}.

With exception to @code{bus_poll} and @code{bus_poll_timed},
all functions return @code{0} upon successful completion,
and @code{-1} in case of failure. @code{bus_poll} and
@code{bus_poll_timed} return @code{NULL} on failure.
On failure on all functions set @code{errno} to indicate
what went wrong.

@file{<bus.h>} defines the following functions:

@table @code
@item int bus_create(const char *file, int flags, char **out_file)
This function creates a bus with the asscoiated pathname
specifed by the value of the parameter @code{file}. If
@code{file} is @code{NULL} a random pathname is selected.
This pathname adheres to the convention set forth by
in @ref{Standard}.

If @code{file} is not @code{NULL} the function fails if the
file already exists if @code{flags} contains @code{BUS_EXCL}.
Otherwise if @code{file} is not @code{NULL}, the function
does nothing if the file already exists.

If @code{flags} contains @code{BUS_INTR}, the function fails
if it is interrupted.

Unless @code{out_file} is NULL, the pathname of the bus
should be stored in a new char array stored in @code{*out_file}.
The caller must free the allocated stored in @code{*out_file}.

If the processes cannot allocate enough memory to perform
the action, the function sets @code{errno} to @code{ENOMEM}
and fails. It may also fail and set @code{errno} to any of
the errors specified for the system calls @code{open} and
@code{write}.

@item int bus_unlink(const char *file)
This function removes the bus assoicated with the pathname
stored in the parameter @code{file}. The function also
unlinks the file.

The function may set @code{errno} to any of the following
values and fail for the specified reasons:
@table @code
@item EINVAL
The bus does not exist.
@item EACCES
Operation permission is denied to the calling process.
@item EPERM
The user does not have permission to remove the bus.
@end table
@noindent
It may also fail and set @code{errno} to any of the errors
specified for the system calls @code{unlink} and @code{open},
and the functions @code{semget} and @code{shmget}.

@item int bus_open(bus_t *bus, const char *file, int flags)
This function acquires resources required for the process
to use the bus associated with the filename stored in the
parameter @code{file}. The function also stores the resources
in @code{bus} for use by other @command{bus} functions.

Values for @code{flags} are constructed by a bitwise
inclusive @sc{or} of flags from the following list.
@table @code
@item BUS_RDONLY
The process will only be using the bus for receiving messages.
@item BUS_WRONLY
The process will only be using the bus for sending messages.
@item BUS_RDWR
The process will use the bus for both receiving and sending
messages.
@end table

The function may set @code{errno} to any of the following
values and fail for the specified reasons:
@table @code
@item ENOMEM
The process cannot allocate enough memory to perform the
action.
@item EACCES
Operation permission is denied to the calling process.
@item EINVAL
The described bus does not exist.
@end table
@noindent
It may also fail and set @code{errno} to any of the errors
specified for the system call @code{open}.

@item int bus_close(bus_t *bus)
This function disposes of resources allocated to the
process, as referenced in the parameter @code{bus}.

The function fails and sets @code{errno} to @code{EINVAL}
if the bus does not exist.

@item int bus_write(const bus_t *bus, const char *message, int flags)
This function broadcasts a message on the bus whose
information is stored in the parameter @code{bus}. The
message read by the function is stored in the parameter
@code{message}. It may not exceeed 2048 bytes, including
NUL termination.

The function shall fail, and set @code{errno} to
@code{EAGAIN}, if the call would suspend the process and
@code{flags} contains @code{BUS_NOWAIT}.

The function may fail and set @code{errno} to any of the
errors specified for the function @code{semop}.

@item int bus_write_timed(const bus_t *bus, const char *message, const struct timespec *timeout, clockid_t clockid)
This function behaves like @code{bus_write}, except if it
is not able to write the message within the specified time,
it will fail and set @code{errno} to @code{EAGAIN}. The
time is specified as an absolute time using the parameter
@code{timeout}. The behaviour is unspecified if @code{timeout}
is @code{NULL}. @code{timeout} is measured with the clock whose
identifier is specified by the parameter @code{clockid}. This
clock must be a predicitable clock@footnote{There are probably
other, undocumented, seemingly arbitrary restrictions too.}.

The function may fail and set @code{errno} to any of the
errors specified for the functions @code{semop} and
@code{clock_gettime}.

@item int bus_read(const bus_t *bus, int (*callback)(const char *message, void *user_data), void *user_data)
This function waits for new message to be sent on the bus
specified in the @code{bus} parameter, as provieded by a
previous call to the function @code{bus_open}. Once a
message is received, the parameter-function @code{callback}
is invoked. The parameter @code{message} in @code{callback}
is the received message, and @code{user_data} in
@code{callback} should be @code{user_data} from @code{bus_read}.
However, once the function [@code{bus_read}] has ensured
that it will receive any message sent on the bus, it shall
invoke the parameter-function @code{callback} with
@code{message} set to @code{NULL}, to notify the process that
it can perform any action that requires that it is listening
on the bus.

After @code{callback} returns, @code{message} may be override.
Therefore @code{callback} should copy message and start a new
thread that uses the copy of @code{message}. @code{callback}
shall return @code{-1} on failure, @code{0} if the function
[@code{bus_read}] should stop listening, or @code{1} if
the function should continue listening.

The function may fail and set @code{errno} to any of the
errors specified for the function @code{semop}.

@item int bus_read_timed(const bus_t *bus, int (*callback)(const char *message, void *user_data), void *user_data, const struct timespec *timeout, clockid_t clockid)
This function behaves like @code{bus_read}, except it will
automatically fail and set @code{errno} to @code{EAGAIN} when
the specified time has passed. The time is specified as an
absolute time using the parameter @code{timeout}. The
behaviour is unspecified if @code{timeout} is @code{NULL}.
@code{timeout} is measured with the clock whose identifier
is specified by the parameter @code{clockid}. This clock
must be a predicitable clock@footnote{There are probably
other, undocumented, seemingly arbitrary restrictions too.}.

The function may fail and set @code{errno} to any of the
errors specified for the functions @code{semop} and
@code{clock_gettime}.

@item int bus_poll_start(bus_t *bus)
@itemx int bus_poll_stop(const bus_t *bus)
@itemx const char *bus_poll(bus_t *bus, int flags)
@itemx const char *bus_poll_timed(bus_t *bus, const struct timespec *timeout, clockid_t clockid)
The function @code{bus_poll} waits for a message to be
broadcasted on the bus, and return the message it receives.
The function fails if @code{flags} contains @code{BUS_NOWAIT}
and there is not already a message waiting on the bus.
Received messages shall be copied and parsed, and acted
upon, in a separate thread, and the function @code{bus_poll}
or the function @code{bus_poll_stop} called again as soon
as possible.

The funcion @code{bus_poll_start} must be called before
@code{bus_poll} is called for the first time. When the
process is done listening on the bus, it must call the
function @code{bus_poll_stop}.

The function @code{bus_poll_timed} behaves like the function
@code{bus_poll}, except if it is not able to read a message
within the specified time, it will fail and set @code{errno}
to @code{EAGAIN}. The time is specified as an absolute time
using the parameter @code{timeout}. The behaviour is
unspecified if @code{timeout} is @code{NULL}. @code{timeout}
is measured with the clock whose identifier is specified by
the parameter @code{clockid}. This clock must be a predicitable
clock@footnote{There are probably other, undocumented,
seemingly arbitrary restrictions too.}.

Upon successful completion, the functions @code{bus_poll} and
@code{bus_poll_timed} returns the received message.

These functions may fail and set @code{errno} to any of the
errors specified for the function @code{semop}. The function
@code{bus_poll_timed} may also set @code{errno} to any of
the errors specified for @code{clock_gettime}.

@item int bus_chown(const char *file, uid_t owner, gid_t group)
This function changes the owner and the group of the bus,
associated with the file whose pathname is stored in the
parameter @code{file}, to the owner and group specified by
the parameters @code{owner} and @code{group}, respectively.

The current ownership of a bus can be retrieved by calling
@code{stat} over the pathname of the bus.

The function may fail and set @code{errno} to any of the
errors specified for the functions @code{bus_open},
@code{chown}, @code{semget}, @code{shmget}, and @code{shmctl}
as well as any errors specified for the commands
@code{IPC_STAT} and @code{IPC_SET} for the function
@code{semctl}.

@item int bus_chmod(const char *file, mode_t mode)
This function gives access to the bus associated with the
file whose pathname is stored in the parameter @code{file}
according to the following rules:

@itemize @bullet{}
@item
If @code{mode} contains any of the bits @code{S_IRWXU}
contains, the owner should be given full access to the
bus. Otherwise the owner should have no access.
@item
If @code{mode} contains any of the bits @code{S_IRWXG}
contains, the group should be given read and write
access to the bus. Otherwise the group should have no
access.
@item
If @code{mode} contains any of the bits @code{S_IRWXO}
contains, users that are neither the owner nor member
of the group should be given read and write access to
the bus. Otherwise they should have no access.
@end itemize

The current permissions of a bus can be retrieved by calling
@code{stat} over the pathname of the bus.

The function may fail and set @code{errno} to any of the
errors specified for the functions @code{bus_open},
@code{chmode}, @code{semget}, @code{shmget}, and @code{shmctl}
as well as any errors specified for the commands
@code{IPC_STAT} and @code{IPC_SET} for the function
@code{semctl}.
@end table

There is not reason for poking around in @code{bus_t}
(@code{struct bus}). It should be considered opaque.
You can read the documentation in @file{<bus.h>} if
you want to know what is in it.




@node Protocol
@chapter Protocol

@command{bus} is built upon following three procedures.

@noindent
@code{create}
@example
@w{@xrm{}Select a filename.@xtt{}}

@w{@xrm{}Create XSI semaphore array @{@code{S} = 0, @code{W} = 0, @code{X} = 1, @code{Q} = 0, @code{N} = 0@}@xtt{}}
@w{@xrm{}with random key. Store the semaphore array's key in decimal form@xtt{}}
@w{@xrm{}on the first line in the selected file.@xtt{}}

@w{@xrm{}Create XSI shared memory, with an allocation of 2048 bytes, with@xtt{}}
@w{@xrm{}a random key. Store the shared memory's key in decimal form on@xtt{}}
@w{@xrm{}the second line in the selected file.@xtt{}}
@end example

@noindent
@code{broadcast}
@example
with P(X):
  Z(W)
  @w{@xrm{}Write NUL-terminate message to shared memory@xtt{}}
  with V(N): -- (1)
    Q := 0
    Z(S)

-- (1) @w{@xrm{}may be omitted if semaphores are known that@xtt{}}
   @w{P()@xrm{}, @xtt{}Z()@xrm{}, @xtt{}V()@xrm{} cannot create a race condition@xtt{}}
   @w{@xrm{}with a processes running @xtt{}Z()@xrm{}.@xtt{}}
@end example

@noindent
@code{listen}
@example
with V(S):
  forever:
    V(Q)
    Z(Q)
    @w{@xrm{}Read NUL-terminated message from shared memory@xtt{}}
    if breaking:
      break
    with V(W):
      with P(S):
        Z(S)
        Z(N)
@end example

@noindent
@code{V(a)} means that semaphore a is released.@*
@code{P(a)} means that semaphore a is acquired.@*
@code{Z(a)} means that the process waits for semaphore a to become 0.@*
@code{with P(a)} that @code{P(a)} is done before the entering the scope,
and @code{V(a)} is done when exiting the scope. It also means that
these actions [@code{P(a)} and @code{V(a)}] are undone when the process
exits, or if the call fails.@*
@code{with V(a)} is to @code{V(a)} as @code{with P(a)} is to @code{P(a)}.



@node Rationale
@chapter Rationale

We need an interprocess communication system similar
to message queues. But we need broadcasting rather than
anycasting, so we have a fast, simple and daemonless
system for announcing events to any processes that
might be interested.



@node Examples
@chapter Examples

This chapter contains usecase examples and
API-demonstrations. You will find that they are (on
a standard installation) installed on your system.

@menu
* Audio-volume control::
* Telephony and music::
* Timed::
* Nonblocking::
* Daemon-depedencies::
@end menu




@node Audio-volume control
@section Audio-volume control

Assume you have program that display the audio volume.
This program checks every second third if the volume
have changed.

Also assume that you use @command{amixer} to change the
volume, most often by using keybindings via @command{xbindkeys}.

To reduce the delay, you want to send a signal to the
monitor program that the volume have changed. For this
more primitive IPC is sufficient, but lets assume there
are other programs interested in this information too.

To accomplish this, you create a wrapper for @command{amixer}
that broadcasts updates on a bus. This wrapper is
installed as @command{~/.local/bin/amixer}, and
@command{~/.local/bin/} is included in @env{$PATH}
before @command{/usr/bin}.
@*

@noindent
Before starting run @command{./init}, this code is
should be run from your profile file if you want to
implement this on your system. After running
@command{./init}, you can start one or more listeners
by running @command{./alsa-monitor}.

To change the volume run
@code{./amixer -c 0 -- set Master 5%+} or similar.

When you are done run @command{./cleanup}.


@subsubheading @file{./amixer}
@example
#!/bin/sh
/usr/bin/amixer "$@@"
for arg in "$@@"; do
  if [ "$@{arg@}" = "set" ]  || \
     [ "$@{arg@}" = "sset" ] || \
     [ "$@{arg@}" = "cset" ]; then
    exec bus broadcast "/tmp/example-bus" '0 volume-changed *'
  fi
done
@end example


@subsubheading @file{./cleanup}
@example
#!/bin/sh
exec bus remove "/tmp/example-bus"
@end example


@subsubheading @file{./init}
@example
#!/bin/sh
bus create "/tmp/example-bus"

# @w{@xrm{}The following code is more suitable in the real world,@xtt{}}
# @w{@xrm{}if used, the other files should use @xtt{}"$@{BUS_AUDIO@}"}
# @w{@xrm{}instead of @xtt{}"/tmp/example-bus"@xrm{}.@xtt{}}
# 
# export BUS_AUDIO="$@{XDG_RUNTIME_DIR@}/bus/audio"
# if [ ! -f "$@{BUS_AUDIO@}" ]; then
#   bus create "$@{BUS_AUDIO@}"
# fi
@end example


@subsubheading @file{./monitor}
@example
#!/bin/sh
if [ $# = 1 ]; then
  if [ "$(echo "$@{1@}" | cut -d ' ' -f 2)" = "volume-changed" ]; then
    printf '\e[H\e[2J'
    amixer get Master
  fi
  exit 0
fi

exec 2>/dev/null

printf '\e[?1049h\e[H\e[2J'
trap -- "printf '\e[?1049l'" SIGINT
bus listen "/tmp/example-bus" \'"$@{0/\'/\'\\\'\'@}"\'' "$@{msg@}"'
@end example



@node Telephony and music
@section Telephony and music

Assume you have a music player and a telephony program.
You might like it if the music player pauses whenever
you make or receive a call. You may also like it, if
the music resumed when the call ended.

In this example we will assume you the have @command{mocp}
(@command{moc} package) running. And we will use the shell to
simulate a telephony program.
@*

@noindent
First of, run make to build this example. Before
starting run @command{./init}. And when you are
done run @command{./cleanup}.

In one terminal run @command{./monitor}. This program
will pause @command{mocp} when you make or receive a call,
it will also resume @command{mocp} when all calls have
ended if it did pause @command{mocp}.

Then start any positive number of terminals.
We will pretend that each of them are telephony
programs. To make or receive a call, run
@command{./receive-or-make-call}, when you want to
end the pretend call, run @command{./end-call} from
the terminal (or more accurately, from the same
process.)


@subsubheading @file{./Makefile}
@example
COMMANDS = init cleanup monitor end-call receive-or-make-call

all: $@{COMMANDS@}
%: %.c
        $@{CC@} -Wall -Wextra -pedantic -std=c99 -lbus -o $@@ $<
clean:
        -rm $@{COMMANDS@}

.PHONY: all clean
@end example


@subsubheading @file{./cleanup.c}
@example
#include <bus.h>
#include <stdio.h>

int main()
@{
  return bus_unlink("/tmp/example-bus") && (perror("cleanup"), 1);
@}
@end example


@subsubheading @file{./end-call.c}
@example
#include <bus.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>

#define t(stmt)  if (stmt) goto fail

static char message[BUS_MEMORY_SIZE];

int main()
@{
  bus_t bus;
  sprintf(message, "%ji unforce-pause", (intmax_t)getppid());
  /* @w{@xrm{}Yes, PPID; in this example we pretend the shell is the telephony process.@xtt{}} */
  t (bus_open(&bus, "/tmp/example-bus", BUS_WRONLY));
  t (bus_write(&bus, message, 0));
  bus_close(&bus);
  return 0;

fail:
  perror("end-call");
  bus_close(&bus);
  return 1;
@}
@end example


@subsubheading @file{./init.c}
@example
#include <bus.h>
#include <stdio.h>

int main()
@{
  return bus_create("/tmp/example-bus", 0, NULL) && (perror("init"), 1);
@}
@end example


@subsubheading @file{./monitor.c}
@example
#include <bus.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define t(stmt)  if (stmt) goto fail

static size_t pauser_count = 0;
static size_t pausers_size = 0;
static char* pausers = NULL;

static int is_moc_playing(void)
@{
  return !WEXITSTATUS(system("env LANG=C mocp -i 2>/dev/null |"
                             "grep 'State: PLAY' >/dev/null"));
@}

/* @w{@xrm{}In a proper implementation, message whould be copyied, and then@xtt{}}
 * @w{@xrm{}a new thread would be created that parsed the copy. But that is@xtt{}}
 * @w{@xrm{}too much for an example, especially since it would also require@xtt{}}
 * @w{@xrm{}a mutex to make sure two threads do not modify data at the same@xtt{}}
 * @w{@xrm{}time, causing chaos.@xtt{}} */
static int callback(const char *message, void *user_data)
@{
  char *msg = NULL;
  size_t len = 0;
  if (message == 0)
    return 1;
  while ((len < 2047) && message[len])
    len++;
  msg = malloc((len + 1) * sizeof(char));
  t (msg == NULL);
  memcpy(msg, message, len * sizeof(char));
  msg[len] = 0;
  /* @w{@xrm{}BEGIN run as in a separate thread@xtt{}} */
  if (pauser_count || is_moc_playing()) @{
    char *begin = strchr(msg, ' ');
    ssize_t pid;
    int requests_pause;
    if (begin == NULL)
      goto done;
    *begin++ = 0;
    pid = (ssize_t)atoll(msg);
    if (pid < 1) /* @w{@xrm{}We need a real PID, too bad there is@xtt{}}
                  * @w{@xrm{}no convient way to detect if it dies.@xtt{}} */
      goto done;
    if ((strstr(begin, "force-pause ") == begin) ||
        !strcmp(begin, "force-pause"))
      requests_pause = 1;
    else if ((strstr(begin, "unforce-pause ") == begin) ||
             !strcmp(begin, "unforce-pause"))
      requests_pause = 0;
    else
      goto done;
    if ((size_t)pid >= pausers_size) @{
      pausers = realloc(pausers, (size_t)(pid + 1) * sizeof(char));
      t (pausers == NULL); /* @w{@xrm{}Let's ignore the memory leak.@xtt{}} */
      memset(pausers + pausers_size, 0,
             ((size_t)(pid + 1) - pausers_size) * sizeof(char));
      pausers_size = (size_t)(pid + 1);
    @}
    if (pausers[pid] ^ requests_pause) @{
      pauser_count += requests_pause ? 1 : -1;
      pausers[pid] = requests_pause;
      if (pauser_count == (size_t)requests_pause)
        system(requests_pause ? "mocp -P" : "mocp -U");
    @}
  @}
  /* @w{@xrm{}END run as in a separate thread@xtt{}} */
  goto done;
  (void) user_data;

fail:
  perror("monitor");
  return -1;

done:
  free(msg);
  return 1;
@}

int main()
@{
  bus_t bus;
  t (bus_open(&bus, "/tmp/example-bus", BUS_RDONLY));
  t (bus_read(&bus, callback, NULL));
  bus_close(&bus);
  free(pausers);
  return 0;

fail:
  perror("monitor");
  bus_close(&bus);
  free(pausers);
  return 1;
@}
@end example


@subsubheading @file{./receive-or-make-call.c}
@example
#include <bus.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>

#define t(stmt)  if (stmt) goto fail

static char message[BUS_MEMORY_SIZE];

int main()
@{
  bus_t bus;
  sprintf(message, "%ji force-pause", (intmax_t)getppid());
  /* @w{@xrm{}Yes, PPID; in this example we pretend the shell is the telephony process.@xtt{}} */
  t (bus_open(&bus, "/tmp/example-bus", BUS_WRONLY));
  t (bus_write(&bus, message, 0));
  bus_close(&bus);
  return 0;

fail:
  perror("receive-or-make-call");
  bus_close(&bus);
  return 1;
@}
@end example



@node Timed
@section Timed

This example shows how to use timed operations.

First of, run make to build this example.

To start the example run @command{./init}. When you are
done run @command{./cleanup}.

Running instances of @command{./poll} will wait for new
messages continuously, but with one second timeouts.

@command{./slow-poll} works like @command{./poll}, except
it will sleep for one second every time it receives
a message.

Running instances of @command{./read} will read for ten
seconds and then time out.

@command{./poll}, @command{./read}, and @command{./slow-poll}
will stop if the message "stop" is broadcasted.

@command{./write} will wait for atmost a tenth of a
seconds before failing. This means that if two instances
of @command{./write} is started at the same time one of
them will fail if @command{./slow-poll} is running.

@command{./poll}, @command{./read}, @command{./init} and
@command{./cleanup} are run without any additional
arguments. @command{./write} is run with the message
as the second argument.


@subsubheading @file{./Makefile}
@example
COMMANDS = init cleanup write poll read slow-poll

all: $@{COMMANDS@}
%: %.c
        $@{CC@} -Wall -Wextra -pedantic -std=c99 -lbus -o $@@ $<
clean:
        -rm $@{COMMANDS@}

.PHONY: all clean
@end example


@subsubheading @file{./cleanup.c}
@example
#include <bus.h>
#include <stdio.h>

int main()
@{
  return bus_unlink("/tmp/example-bus") && (perror("cleanup"), 1);
@}
@end example


@subsubheading @file{./init.c}
@example
#include <bus.h>
#include <stdio.h>

int main()
@{
  return bus_create("/tmp/example-bus", 0, NULL) && (perror("init"), 1);
@}
@end example


@subsubheading @file{./poll.c}
@example
#include <bus.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define t(stmt)  if (stmt) goto fail

int main()
@{
  bus_t bus;
  const char *message;
  long long tick = 0;
  struct timespec timeout;
  t (bus_open(&bus, "/tmp/example-bus", BUS_RDONLY));
  t (bus_poll_start(&bus));
  for (;;) @{
    t(clock_gettime(CLOCK_MONOTONIC, &timeout));
    timeout.tv_sec += 1;
    message = bus_poll_timed(&bus, &timeout, CLOCK_MONOTONIC);
    if (message == NULL) @{
      t (errno != EAGAIN);
      printf("waiting... %lli\n", ++tick);
      continue;
    @}
    tick = 0;
    message = strchr(message, ' ') + 1;
    if (!strcmp(message, "stop"))
      break;
    printf("\033[01m%s\033[21m\n", message);
  @}
  t (bus_poll_stop(&bus));
  bus_close(&bus);
  return 0;

fail:
  perror("poll");
  bus_poll_stop(&bus);
  bus_close(&bus);
  return 1;
@}
@end example


@subsubheading @file{./read.c}
@example
#include <bus.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define t(stmt)  if (stmt) goto fail

static int callback(const char *message, void *user_data)
@{
  (void) user_data;

  if (message == NULL)
    return 1;

  message = strchr(message, ' ') + 1;
  if (!strcmp(message, "stop"))
    return 0;
  printf("%s\n", message);
  return 1;
@}

int main()
@{
  bus_t bus;
  struct timespec timeout;
  t (bus_open(&bus, "/tmp/example-bus", BUS_RDONLY));
  t (clock_gettime(CLOCK_MONOTONIC, &timeout));
  timeout.tv_sec += 10;
  t (bus_read_timed(&bus, callback, NULL, &timeout, CLOCK_MONOTONIC));
  bus_close(&bus);
  return 0;

fail:
  perror("poll");
  bus_poll_stop(&bus);
  bus_close(&bus);
  return 1;
@}
@end example


@subsubheading @file{./slow-poll.c}
@example
#include <bus.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define t(stmt)  if (stmt) goto fail

int main()
@{
  bus_t bus;
  const char *message;
  long long tick = 0;
  struct timespec timeout;
  t (bus_open(&bus, "/tmp/example-bus", BUS_RDONLY));
  t (bus_poll_start(&bus));
  for (;;) @{
    t (clock_gettime(CLOCK_MONOTONIC, &timeout));
    timeout.tv_sec += 1;
    message = bus_poll_timed(&bus, &timeout, CLOCK_MONOTONIC);
    if (message == NULL) @{
      t (errno != EAGAIN);
      printf("waiting... %lli\n", ++tick);
      continue;
    @}
    tick = 0;
    message = strchr(message, ' ') + 1;
    if (!strcmp(message, "stop"))
      break;
    printf("\033[01m%s\033[21m\n", message);
    sleep(1);
  @}
  t (bus_poll_stop(&bus));
  bus_close(&bus);
  return 0;

fail:
  perror("poll");
  bus_poll_stop(&bus);
  bus_close(&bus);
  return 1;
@}
@end example


@subsubheading @file{./write.c}
@example
#include <bus.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>

#define t(stmt)  if (stmt) goto fail

static char message[BUS_MEMORY_SIZE];

int main(int argc, char *argv[])
@{
  bus_t bus;
  struct timespec timeout;
  if (argc < 2) @{
    fprintf(stderr, "%s: USAGE: %s message\n", argv[0], argv[0]);
    return 2;
  @}
  sprintf(message, "0 %s", argv[1]);
  t (bus_open(&bus, "/tmp/example-bus", BUS_WRONLY));
  t (clock_gettime(CLOCK_MONOTONIC, &timeout));
  timeout.tv_nsec += 100000000L;
  t (bus_write_timed(&bus, message, &timeout, CLOCK_MONOTONIC));
  bus_close(&bus);
  return 0;

fail:
  perror("write");
  bus_close(&bus);
  return 1;
@}
@end example



@node Nonblocking
@section Nonblocking

This example shows how to use bus_poll instead of bus_read,
and how to do non-blocking polling and non-blocking writing.

First of, run make to build this example.

To start the example run @command{./init}. When you are done
run @command{./cleanup}.

Running instances of @command{./poll} will check every second
if there is a new inbound message. Between these checks
@command{./write} will wait for all @command{./poll}:s to
receive the message. This means that @command{./write} blocks
while @command{./poll} sleeps. If two or more instances of
@command{./write} is started at approximately the same time,
only one will continue to write a message on the bus, the
others will fail.

@command{./poll} will stop if the message ``stop'' is
broadcasted.

@command{./poll}, @command{./init} and @command{./cleanup}
are run without any additional arguments. @command{./write}
is run with the message as the second argument.


@subsubheading @file{./Makefile}
@example
COMMANDS = init cleanup write poll

all: $@{COMMANDS@}
%: %.c
        $@{CC@} -Wall -Wextra -pedantic -std=c99 -lbus -o $@@ $<
clean:
        -rm $@{COMMANDS@}

.PHONY: all clean
@end example


@subsubheading @file{./cleanup.c}
@example
#include <bus.h>
#include <stdio.h>

int main()
@{
  return bus_unlink("/tmp/example-bus") && (perror("cleanup"), 1);
@}
@end example


@subsubheading @file{./init.c}
@example
#include <bus.h>
#include <stdio.h>

int main()
@{
  return bus_create("/tmp/example-bus", 0, NULL) && (perror("init"), 1);
@}
@end example


@subsubheading @file{./poll.c}
@example
#include <bus.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define t(stmt)  if (stmt) goto fail

int main()
@{
  bus_t bus;
  const char *message;
  long long tick = 0;
  t (bus_open(&bus, "/tmp/example-bus", BUS_RDONLY));
  t (bus_poll_start(&bus));
  for (;;) @{
    message = bus_poll(&bus, BUS_NOWAIT);
    if (message == NULL) @{
      t (errno != EAGAIN);
      printf("waiting... %lli\n", ++tick);
      sleep(1);
      continue;
    @}
    tick = 0;
    message = strchr(message, ' ') + 1;
    if (!strcmp(message, "stop"))
      break;
    printf("\033[01m%s\033[21m\n", message);
  @}
  t (bus_poll_stop(&bus));
  bus_close(&bus);
  return 0;

fail:
  perror("poll");
  bus_poll_stop(&bus);
  bus_close(&bus);
  return 1;
@}
@end example


@subsubheading @file{./write.c}
@example
#include <bus.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>

#define t(stmt)  if (stmt) goto fail

static char message[BUS_MEMORY_SIZE];

int main(int argc, char *argv[])
@{
  bus_t bus;
  if (argc < 2) @{
    fprintf(stderr, "%s: USAGE: %s message\n", argv[0], argv[0]);
    return 2;
  @}
  sprintf(message, "0 %s", argv[1]);
  t (bus_open(&bus, "/tmp/example-bus", BUS_WRONLY));
  t (bus_write(&bus, message, BUS_NOWAIT));
  bus_close(&bus);
  return 0;

fail:
  perror("write");
  bus_close(&bus);
  return 1;
@}
@end example



@node Daemon-depedencies
@section Daemon-depedencies

TODO



@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texinfo

@bye

